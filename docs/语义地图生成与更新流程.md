# 语义地图生成与更新流程说明文档

## 📋 目录
1. [核心概念](#核心概念)
2. [数据流概览](#数据流概览)
3. [地图生成流程](#地图生成流程)
4. [位姿获取机制](#位姿获取机制)
5. [地图架构](#地图架构)
6. [资源消耗分析](#资源消耗分析)

---

## 核心概念

### 地图类型
```
全局地图 (Full Map)     局部地图 (Local Map)
480×480 (24m×24m)      240×240 (12m×12m)
存储长期记忆           实时建图与规划
```

### 地图通道结构
```python
# full_map.shape = (1, N+4, 480, 480)
通道 0: 障碍物地图 (obstacles)
通道 1: 已探索区域 (explored_area)
通道 2: 当前位置标记 (current_location)
通道 3: 历史访问区域 (past_locations)
通道 4~: 动态语义类别 (floor, wall, kitchen, ...)
```

---

## 数据流概览

```
Habitat 仿真环境
    ↓ envs.step(action)
RGB (480,640,3) + Depth (480,640,1) + sensor_pose [Δx,Δy,Δθ]
    ↓
[语义分割] GroundedSAM
    ↓
Masks (N,480,640) → 合并同类 → (len(detected_classes),480,640)
    ↓
[预处理] 下采样 4x → batch_obs (1, N+4, 160, 160)
    ↓
[建图核心] mapping_module.forward(batch_obs, poses)
    ├─① 点云生成: Depth → (120,160,3) 3D点
    ├─② 坐标变换: 相机系 → 智能体系 → 世界系
    ├─③ 体素投影: 点云+语义 → (N+1,100,100,80) 3D体素
    ├─④ 高度压缩: 沿z轴sum → (N+1,100,100) 2D
    ├─⑤ 位姿变换: 旋转+平移 → local_map坐标系
    └─⑥ 多帧融合: max(历史, 当前) → 更新local_map
    ↓
[地图管理] update_map()
    ├─ 更新当前位置标记 (3×3区域)
    ├─ local_map → full_map (写回到全局)
    └─ 更新全局位姿
    ↓
full_map (1,N+4,480,480) + full_pose (1,3) [x,y,θ]
```

---

## 地图生成流程

### 1. 初始化阶段
```python
# mapping.py init_map_and_pose()
full_map = zeros(1, N+4, 480, 480)  # 全零初始化
local_map = zeros(1, N+4, 240, 240)

# 智能体位姿初始化 (地图中心)
full_pose = [12.0, 12.0, 0.0]  # (x=12m, y=12m, heading=0°)
local_pose = [6.0, 6.0, 0.0]   # 局部地图中心

# 标记智能体位置 (3×3像素区域)
full_map[:, 2:4, 238:241, 238:241] = 1.0
```

### 2. 环视建图 (Look Around)
```python
# ZS_Evaluator_mp.py _look_around()
for step in range(12):  # 12次 × 30° = 360°
    action = TURN_LEFT  # 左转30°
    obs = envs.step(action)
    
    # ===== 语义分割 =====
    batch_obs = self._batch_obs(obs)  # (1, N+4, 160, 160)
    # 调用链: _batch_obs → _preprocess_obs → _get_sem_pred
    #   → segment_module.segment() [GroundedSAM]
    
    # ===== 位姿更新 =====
    sensor_pose = obs['sensor_pose']  # [Δx, Δy, Δθ] 相对位移
    poses = torch.tensor(sensor_pose)  # 米, 米, 弧度
    
    # ===== 核心建图 =====
    mapping_module(batch_obs, poses)  # 前向传播
    full_map, full_pose, one_step_map = mapping_module.update_map(...)
    
    # ===== 地图处理 =====
    traversible, floor, frontiers = _process_map(full_map[0])
```

### 3. 导航中实时更新
```python
# ZS_Evaluator_mp.py rollout()
for step in range(12, 500):
    action = policy(value_map, ...)  # FMM路径规划
    obs = envs.step(action)
    
    # 相同的建图流程
    batch_obs = self._batch_obs(obs)
    poses = torch.tensor(obs['sensor_pose'])
    mapping_module(batch_obs, poses)
    full_map, full_pose, one_step_map = mapping_module.update_map(...)
```

---

## 位姿获取机制

### sensor_pose 生成流程
```
Habitat 仿真器 (sim.get_agent_state())
    ↓
SensorPoseSensor.get_observation() [sensors.py Line 40-48]
    ↓
get_pose_change(sim, last_sim_location) [pose_utils.py Line 72-78]
    ├─ 当前位姿: get_sim_location(sim)
    │   ├─ position: agent_state.position [x, y, z]
    │   ├─ rotation: agent_state.rotation (四元数)
    │   └─ 转换: 坐标系变换 + 四元数→欧拉角
    │        x = -position[2]  # Habitat z → 本地x
    │        y = -position[0]  # Habitat x → 本地y
    │        θ = euler_angles[1]  # 归一化到[-π, π]
    │
    └─ 相对变化: get_rel_pose_change(curr, last)
        dx = dist * cos(θ)  # 前后位移 (智能体坐标系)
        dy = dist * sin(θ)  # 左右位移
        dθ = θ_curr - θ_last  # 朝向变化
    ↓
返回: sensor_pose = [Δx, Δy, Δθ]  # 米, 米, 弧度
```

### 关键代码
```python
# habitat_extensions/sensors.py
class SensorPoseSensor(Sensor):
    def get_observation(self, observations, episode, **kwargs):
        # 第一步: 获取起始位姿
        if not self.episode_start:
            self.last_sim_location = get_start_sim_location(
                episode.start_position, 
                episode.start_rotation
            )
            self.episode_start = True
        
        # 第二步: 计算相对位姿变化
        dx, dy, do, self.last_sim_location = get_pose_change(
            self._sim, 
            self.last_sim_location
        )
        
        return [dx, dy, do]  # 返回相对位移
```

---

## 地图架构

### 局部地图与全局地图关系
```python
# mapping.py Line 151-220

# ===== 尺寸定义 =====
MAP_SIZE_CM = 2400  # 24米
MAP_RESOLUTION = 5  # 5cm/pixel
GLOBAL_DOWNSCALING = 2

full_w = full_h = 2400 / 5 = 480  # 全局地图
local_w = local_h = 480 / 2 = 240  # 局部地图

# ===== 滑动窗口机制 =====
lmb = [gx1, gx2, gy1, gy2]  # 局部地图边界 (在全局地图中的位置)

# 提取局部地图 (每步)
local_map = full_map[:, :, gx1:gx2, gy1:gy2]

# 写回全局地图 (每步)
full_map[:, :, gx1:gx2, gy1:gy2] = local_map

# 窗口重置 (每20步)
if (step + 1) % 20 == 0:
    # 重新计算局部边界, 跟随智能体移动
    lmb = _get_local_map_boundaries(agent_loc, ...)
    local_map = full_map[:, :, lmb[0]:lmb[1], lmb[2]:lmb[3]]
```

### 坐标系转换
```
全局坐标系 (Full Pose)    局部坐标系 (Local Pose)
Origin: (0, 0)            Origin: 动态变化
智能体起始: (12, 12, 0)    智能体相对: (6, 6, 0)

关系: full_pose = local_pose + origin
     local_pose = full_pose - origin

origin = [lmb[2] * resolution / 100,  # y方向偏移
          lmb[0] * resolution / 100,  # x方向偏移
          0.0]                        # 朝向不变
```

### 自动居中机制示意图
```
全局地图 (480×480, 24m×24m)           局部地图 (240×240, 12m×12m)
┌─────────────────────────┐           
│                         │           初始状态 (step=0):
│     [0]                 │           ┌───────────┐
│      ↓                  │           │           │
│   ┌─────────────┐       │           │     🤖    │ ← 智能体在中心
│   │             │       │           │    (6,6)  │
│   │      🤖     │  ←────┼───────────│           │
│   │    (12,12)  │       │           └───────────┘
│   │             │       │           origin = (6, 6)
│   └─────────────┘       │           lmb = [120,360,120,360]
│                         │
└─────────────────────────┘

智能体向右移动10步后:
┌─────────────────────────┐           ┌───────────┐
│                         │           │           │
│     ┌─────────────┐     │           │   🤖→     │ ← 偏离中心
│     │       🤖→   │     │           │  (8,6)    │
│     │     (14,12) │     │           └───────────┘
│     └─────────────┘     │           origin还是(6,6)
│                         │           local_pose = (8, 6)
└─────────────────────────┘

第25步触发自动居中:
┌─────────────────────────┐           ┌───────────┐
│                         │           │           │
│       ┌─────────────┐   │           │     🤖    │ ← 重新居中!
│       │      🤖     │   │           │    (6,6)  │
│       │    (14,12)  │   │           └───────────┘
│       └─────────────┘   │           origin更新为(8,6)
│                         │           lmb = [140,380,120,360]
└─────────────────────────┘           full_pose不变=(14,12)

关键：
- full_pose 是全局绝对位置，不变
- origin 每25步重新计算 (窗口左上角)
- local_pose = full_pose - origin (相对位置)
- 局部窗口跟随智能体滑动，保证智能体始终在视野中心
```

---

## 资源消耗分析

### 显存占用 (单环境)
```python
# 1. 地图张量
full_map:  4 × 1 × 24 × 480 × 480 ≈ 22 MB
local_map: 4 × 1 × 24 × 240 × 240 ≈ 5.5 MB

# 2. 3D体素 (峰值)
voxels: 4 × 1 × 21 × 100 × 100 × 80 ≈ 64 MB

# 3. 点云
point_cloud: 4 × 1 × 120 × 160 × 3 ≈ 0.22 MB

# 4. 模型
GroundedSAM: ~1.5 GB
BLIP: ~500 MB
其他: ~500 MB

# 总计: 1.5 + 0.5 + 0.5 + 0.092 ≈ 2.6 GB / 进程
```

### 计算耗时 (每步)
```
语义分割 (GroundedSAM):  30-50 ms (GPU) / 200-500 ms (CPU)
地图更新 (点云投影):     20-40 ms
价值图计算 (BLIP):       10-20 ms
路径规划 (FMM):          5-15 ms
────────────────────────────────────
总计:                     ~105 ms/步  (约9.5 FPS)
```

### 优化策略
1. **动态通道扩展**: 按需增加语义类别通道, 避免预分配
2. **局部地图设计**: 只在240×240区域更新, 降低计算量
3. **滑动窗口**: 每20步重置, 保持智能体在中心
4. **多进程并行**: 8 GPU × 2进程 = 16环境并行

---

## 关键函数调用链

### 完整建图流程
```
ZS_Evaluator_mp._look_around()
  ├─ envs.step(TURN_LEFT)
  ├─ _batch_obs(obs)
  │   └─ _preprocess_obs(obs)
  │       ├─ _concat_obs(obs)  # RGB + Depth
  │       └─ _preprocess_state(state)
  │           ├─ _get_sem_pred(rgb)
  │           │   ├─ segment_module.segment()  # GroundedSAM
  │           │   ├─ _process_labels()
  │           │   └─ _process_masks()
  │           ├─ _preprocess_depth(depth)
  │           └─ 下采样4x
  │
  ├─ mapping_module(batch_obs, poses)
  │   └─ forward()  # mapping.py Line 476-604
  │       ├─ get_point_cloud_from_z_t()
  │       ├─ transform_camera_view_t()
  │       ├─ transform_pose_t()
  │       ├─ splat_feat_nd()  # 3D体素投影
  │       ├─ sum(dim=4)  # 高度压缩
  │       ├─ get_grid()  # 旋转+平移矩阵
  │       ├─ F.grid_sample()  # 位姿变换
  │       └─ torch.max()  # 多帧融合
  │
  └─ update_map()  # mapping.py Line 266-356
      ├─ 更新当前位置标记
      ├─ local_map → full_map
      ├─ 更新全局位姿
      └─ 每20步重置窗口
```

---

## 常见问题

### Q1: 为什么地图是480×480而不是更大?
**A**: 这是性能与范围的权衡设计:
- **物理尺寸**: 480×480像素 @ 5cm/pixel = 2400cm × 2400cm = **24m × 24m**
- **覆盖范围**: 足够覆盖大多数室内场景 (客厅/厨房等单层建筑)
- **内存占用**: 480² × (N+4) × 4字节 ≈ 每环境 22MB (N=20类)
- **计算速度**: 更大的地图会拖慢FMM路径规划和地图更新

### Q2: 如果智能体超出地图边界怎么办?
**A**: 设计上**不会超出边界**, 原因:
1. **初始化**: 智能体始终在地图中心 (12m, 12m) 启动
2. **自动居中**: 每25步执行一次自动居中 (CENTER_RESET_STEPS=25)
3. **滑动窗口**: 局部地图跟随智能体移动, 确保智能体始终在观测范围内
4. **边界保护**: `_get_local_map_boundaries()` 确保局部窗口不会超出全局地图

**自动居中机制详解** (mapping.py Line 310-337):
```python
if ((step + 1) % 25) == 0:  # 每25步触发
    # 1. 保存当前local_map到full_map
    full_map[e, :, gx1:gx2, gy1:gy2] = local_map[e]
    
    # 2. 根据智能体当前位置重新计算局部边界
    loc_r, loc_c = int(agent_y * 100 / 5), int(agent_x * 100 / 5)
    lmb[e] = _get_local_map_boundaries(
        (loc_r, loc_c),   # 当前位置
        (240, 240),        # 局部地图尺寸
        (480, 480)         # 全局地图尺寸
    )
    # 返回: [gx1, gx2, gy1, gy2]
    #   - 如果智能体在中心: [120, 360, 120, 360]
    #   - 如果智能体偏左上: [0, 240, 0, 240]
    #   - 如果智能体偏右下: [240, 480, 240, 480]
    
    # 3. 更新origin (局部地图左上角在全局坐标系的位置)
    origins[e] = [gy1 * 5/100, gx1 * 5/100, 0]
    
    # 4. 提取新的局部地图
    local_map[e] = full_map[e, :, gx1:gx2, gy1:gy2]
    
    # 5. 更新局部位姿 (相对于新origin)
    local_pose[e] = full_pose[e] - origins[e]
```

**边界保护逻辑** (mapping.py Line 208-223):
```python
def _get_local_map_boundaries(agent_loc, local_sizes, full_sizes):
    loc_r, loc_c = agent_loc  # 智能体位置
    local_w, local_h = 240, 240
    full_w, full_h = 480, 480
    
    # 计算以智能体为中心的局部窗口
    gx1, gy1 = loc_r - 120, loc_c - 120
    gx2, gy2 = gx1 + 240, gy1 + 240
    
    # 边界检查：确保窗口不会超出全局地图
    if gx1 < 0:
        gx1, gx2 = 0, 240  # 贴左边界
    if gx2 > 480:
        gx1, gx2 = 240, 480  # 贴右边界
    if gy1 < 0:
        gy1, gy2 = 0, 240  # 贴上边界
    if gy2 > 480:
        gy1, gy2 = 240, 480  # 贴下边界
    
    return [gx1, gx2, gy1, gy2]
```

**为什么不会超出范围?**
1. VLN任务单个episode最大500步, 平均移动距离 < 20m
2. 24m×24m地图足够覆盖大部分室内导航场景
3. 如果真的到边界, 边界保护会将窗口贴边, 保证智能体始终可见

### Q3: 为什么用相对位姿而非绝对位姿?
**A**: 增量式建图避免累积误差, 类似SLAM的里程计方法。每步只用相对位移更新地图。

### Q4: one_step_full_map 的作用?
**A**: 区分"新探索区域"和"历史区域"。每步清空, 只记录当前帧观察, 用于:
- 价值图计算 (鼓励探索新区域)
- 探索边界检测

### Q5: 局部地图如何跟随智能体移动?
**A**: 每25步执行窗口重置 (自动居中):
1. 写回当前local_map到full_map
2. 根据智能体新位置重新计算边界lmb
3. 从full_map提取新的local_map
4. 更新origin和local_pose

### Q6: 语义类别如何动态扩展?
**A**: 使用OrderedSet维护detected_classes, 检测到新类别时:
1. 自动添加到集合 (去重)
2. 动态padding地图通道 (mapping.py _dynamic_process)
3. 构建稀疏掩码矩阵 (只在检测到的类别通道写入)

---

## 代码定位速查

| 功能 | 文件 | 行数 |
|-----|------|------|
| 环视建图 | ZS_Evaluator_mp.py | 500-678 |
| 实时更新 | ZS_Evaluator_mp.py | 1000-1100 |
| 地图初始化 | mapping.py | 229-263 |
| 前向传播 | mapping.py | 476-604 |
| 地图更新 | mapping.py | 266-356 |
| 位姿获取 | sensors.py | 18-48 |
| 位姿计算 | pose_utils.py | 43-78 |
| 语义分割 | ZS_Evaluator_mp.py | 220-320 |

---

*最后更新: 2025-11-08*
