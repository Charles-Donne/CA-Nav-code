# 🗺️ CA-Nav 建图系统完整说明

## 📊 系统架构

### 核心流程
```
RGB-D观察 
  ↓
语义分割 (GroundedSAM)
  ↓
点云生成 (深度 → 3D坐标)
  ↓
坐标变换 (相机坐标 → 世界坐标)
  ↓
3D体素投影 (点云 → 3D体素网格)
  ↓
高度切片 (保留 min_z ~ max_z 范围)
  ↓
2D投影 (俯视图，sum along z-axis)
  ↓
多帧融合 (max pooling)
  ↓
全局地图更新
  ↓
后处理 (形态学操作)
  ↓
导航地图 (floor, traversible, frontiers)
```

## 🗺️ 生成的地图类型

### 1. **原始语义地图** (`full_map`)
**维度**: `(N+4, H, W)` - N是检测到的物体类别数

**通道说明**:
- **Channel 0**: 障碍物 (Obstacles)
  - 来源: 高度切片范围内的所有非地板物体
  - 用途: 碰撞检测、路径规划
  
- **Channel 1**: 探索区域 (Explored Area)
  - 来源: 所有高度范围的投影（`all_height_proj`）
  - 用途: 记录已经观察过的区域
  
- **Channel 2**: 当前位置 (Current Pose)
  - 来源: 智能体的全局坐标
  - 用途: 可视化、轨迹记录
  
- **Channel 3**: 访问地图 (Visited)
  - 来源: 智能体走过的位置
  - 用途: 避免重复访问
  
- **Channel 4~N+3**: 语义类别 (Semantic Classes)
  - 来源: GroundedSAM分割结果 + 高度切片
  - 类别: chair, table, floor, wall, door, bed, sofa, plant, ...
  - 用途: 目标检测、语义导航

### 2. **彩色语义地图** (新增！)
**文件**: 
- `semantic_map.png` - 纯地图
- `semantic_map_with_legend.png` - 带图例

**颜色编码**:
```python
0 → 黑色   # 未探索
1 → 深灰   # 障碍物
2 → 浅灰   # 已探索空区域
3 → 蓝色   # 智能体位置
5+ → 彩色  # 各类物体（每个类别不同颜色）
```

**生成逻辑** (完全复刻 `mapping.py._visualize()`):
1. 从语义通道中提取每个像素的最可能类别
2. 应用颜色映射（使用原程序的调色板）
3. 标记特殊区域（障碍物、已探索、智能体）
4. 翻转坐标系使其与Habitat一致

### 3. **导航地图** (后处理)

#### **Floor Map (地板地图)**
**算法**:
```python
# 1. 提取可导航类别（如 "floor"）
navigable = full_map[navigable_channels].logical_or_reduce()

# 2. 计算空白区域
free_mask = NOT(obstacles OR objects) OR navigable

# 3. 提取地板
floor = explored_area AND free_mask

# 4. 形态学处理
floor = remove_small_objects(floor, min_size=400)
floor = binary_closing(floor, footprint=disk(3))
```

**特点**:
- 移除小噪声（< 400像素的孤立区域）
- 填充小孔（3像素半径的闭运算）
- 连续的可行走区域

#### **Traversible Map (可穿越区域)**
**算法**:
```python
# 1. 计算不可穿越区域
untraversible = obstacles_closed OR objects_closed
untraversible = remove_small_objects(untraversible, 64)

# 2. 可穿越 = 非不可穿越
traversible = NOT(untraversible)

# 3. 合并地板
traversible = floor OR traversible
```

**用途**: 
- A*路径规划的可行区域
- 前景边界提取（FMM - Fast Marching Method）

#### **Frontiers Map (边界地图)**
**算法**:
```python
# 1. 提取探索区域的轮廓
contours = cv2.findContours(explored_area, RETR_EXTERNAL)

# 2. 画出轮廓（3像素宽）
boundary = cv2.drawContours(contours, thickness=3)

# 3. 边界 = 地板 AND 轮廓
frontiers = floor AND boundary
frontiers = remove_small_objects(frontiers, 64)
```

**用途**:
- 探索策略：优先访问边界区域
- 决定是否需要继续探索

### 4. **单体物体地图** (每个类别独立)
**文件**: `map_types/semantic_XX_classname.png`

每个检测到的物体类别都有独立的热力图：
- `semantic_00_chair.png`
- `semantic_01_table.png`
- `semantic_02_floor.png`
- ...

**用途**: 
- 目标物体定位（如"找到冰箱"）
- 语义导航（如"走到桌子旁"）

## 🏗️ 从深度构建房间边界

### **是的，完全可以！** 原程序就是这样做的：

#### **方法1: 障碍物地图直接提取**
```python
obstacles = full_map[0]  # 障碍物通道
room_boundary = cv2.Canny(obstacles, threshold1=50, threshold2=150)
```

#### **方法2: 高度分层分析** (更准确)
```python
# 1. 点云生成（从深度图）
point_cloud = get_point_cloud_from_z(depth, camera_matrix)

# 2. 3D体素网格
voxels = splat_feat_nd(point_cloud)  # (bs, C, 100, 100, 80)

# 3. 墙体检测（高度范围：地面以上 50cm ~ 200cm）
wall_height_range = [50cm/5, 200cm/5]  # [10, 40] 在体素坐标
walls = voxels[..., 10:40].sum(dim=-1) > threshold

# 4. 房间边界 = 墙体的外轮廓
contours = cv2.findContours(walls)
room_boundary = cv2.drawContours(contours, -1, 255, 2)
```

#### **方法3: 深度突变检测** (最直接)
```python
# 1. 计算深度梯度
depth_grad_x = cv2.Sobel(depth, cv2.CV_64F, 1, 0, ksize=5)
depth_grad_y = cv2.Sobel(depth, cv2.CV_64F, 0, 1, ksize=5)
depth_grad = np.sqrt(depth_grad_x**2 + depth_grad_y**2)

# 2. 深度突变 = 边界
boundary_mask = depth_grad > threshold

# 3. 投影到地图
boundary_map = project_to_map(boundary_mask, camera_pose)
```

### **当前程序中的实现**

您的代码已经包含了墙体信息在**障碍物通道**中：

```python
# mapping.py Line 534
agent_height_proj = voxels[..., min_z:max_z].sum(4)
fp_map_pred = agent_height_proj[:, :1, :, :]  # 第一个通道 = 障碍物

# 这包括：
# - 墙体（高度范围内的垂直表面）
# - 家具（桌椅等）
# - 其他障碍物
```

**提取墙体的方法**:
```python
obstacles = full_map[0]
# 墙体特征：连续、较长、相对直
walls = extract_walls(obstacles)

def extract_walls(obstacle_map):
    # 1. 霍夫变换检测直线
    edges = cv2.Canny(obstacle_map.astype(np.uint8) * 255, 50, 150)
    lines = cv2.HoughLinesP(edges, rho=1, theta=np.pi/180, 
                            threshold=50, minLineLength=20, maxLineGap=10)
    
    # 2. 绘制墙线
    wall_map = np.zeros_like(obstacle_map)
    for line in lines:
        x1, y1, x2, y2 = line[0]
        cv2.line(wall_map, (x1,y1), (x2,y2), 255, thickness=2)
    
    return wall_map
```

## 📂 输出文件结构

运行测试后，您会得到：

```
data/minimal_mapping_test/
├── maps_history.npy                # 原始数据（NumPy格式）
├── semantic_map.png                # 🆕 彩色语义地图
├── semantic_map_with_legend.png    # 🆕 带图例的语义地图
├── final_map.png                   # 综合可视化（3×3网格）
├── rgb/
│   ├── step_00.png ~ step_11.png           # 原始RGB
│   └── step_00_annotated.png ~ step_11_annotated.png  # GroundedSAM标注
├── depth/
│   └── step_00.png ~ step_11.png           # 深度图
├── maps/
│   └── map_step_00.png ~ map_step_11.png   # 地图演化动画帧
└── map_types/                      # 🆕 所有地图类型
    ├── obstacles.png               # 障碍物地图
    ├── explored.png                # 探索区域
    ├── floor.png                   # 地板地图
    ├── traversible.png             # 可穿越区域
    ├── frontiers.png               # 边界地图
    ├── semantic_00_chair.png       # 椅子分布
    ├── semantic_01_table.png       # 桌子分布
    ├── semantic_02_floor.png       # 地板检测
    └── ...
```

## 🎯 关键参数

### 深度预处理
```python
MIN_DEPTH = 0.5   # 最小深度 0.5米
MAX_DEPTH = 5.0   # 最大深度 5.0米
# 转换: depth_cm = 50 + depth_raw * 500
```

### 高度切片 (关键！)
```python
MIN_Z = 2         # 配置值，约 -30cm (包含地板)
max_z = 25        # 动态计算，约 85cm
# 覆盖范围: -30cm ~ 85cm (115cm 高度)
# 包括：地板、低矮家具、桌椅腿
```

### 地图参数
```python
MAP_SIZE_CM = 2400        # 24m × 24m
MAP_RESOLUTION = 5        # 5cm/pixel
GLOBAL_DOWNSCALING = 2    # 局部地图缩放
VISION_RANGE = 100        # 5m 视野范围
```

## 🔍 调试技巧

1. **检查深度是否正确转换**:
   ```python
   # 应该看到 50-550cm 的范围
   print(f"深度范围: {depth.min():.0f}cm ~ {depth.max():.0f}cm")
   ```

2. **检查高度切片**:
   ```python
   # 应该看到 min_z=2, max_z=25
   [DEBUG] 高度切片范围: min_z=2 (约-30cm), max_z=25 (约85cm)
   ```

3. **检查语义地图**:
   ```python
   # 打开 semantic_map_with_legend.png
   # 应该看到彩色的房间布局，不同物体不同颜色
   ```

4. **检查障碍物**:
   ```python
   # 应该 > 0
   print(f"障碍物像素: {np.sum(full_map[0] > 0)}")
   ```

## 🚀 下一步优化

1. **墙体提取**: 使用霍夫变换从障碍物通道提取直线墙体
2. **房间分割**: 使用连通域分析分割不同房间
3. **拓扑地图**: 构建房间连接关系图
4. **3D重建**: 保留完整3D体素网格用于高度分析

---

**总结**: 您现在拥有与原程序完全一致的建图系统，包括：
- ✅ 原始语义地图（所有通道）
- ✅ 彩色语义地图（漂亮的可视化）
- ✅ 导航地图（地板、可穿越、边界）
- ✅ 单体物体地图（每个类别独立）
- ✅ 完整的深度处理流程
- ✅ 高度切片优化（包含地板）

可以直接从障碍物通道或深度数据构建房间边界！
